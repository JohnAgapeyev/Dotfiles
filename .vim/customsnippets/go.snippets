
snippet v
	${1} := ${2}

endsnippet
snippet vr
	var ${1:t} ${0:string}

endsnippet
snippet var
	var ${1} ${2} = ${3}

endsnippet
snippet vars
	var (
		${1} ${2} = ${3}
	)

endsnippet
snippet ap
	append(${1:slice}, ${0:value})

endsnippet
snippet bl
	bool

endsnippet
snippet bt
	byte

endsnippet
snippet br
	break

endsnippet
snippet ch
	chan ${0:int}

endsnippet
snippet cs
	case ${1:value}:
		${0:${VISUAL}}
endsnippet
snippet c
	const ${1:NAME} = ${0:0}
endsnippet
snippet co
	const (
		${1:NAME1} = iota
		${0:NAME2}
	)

endsnippet
snippet cn
	continue

endsnippet
snippet df
	defer ${0:func}()

endsnippet
snippet dfr
	defer func() {
		if err := recover(); err != nil {
			${0:${VISUAL}}
		}
	}()

endsnippet
snippet i
	int

endsnippet
snippet im
	import (
		"${1:package}"
	)

endsnippet
snippet in
	interface{}

endsnippet
snippet inf
	interface ${1:name} {
		${2:/* methods */}
	}

endsnippet
snippet if
	if ${1:/* condition */} {
		${2:${VISUAL}}
	}

endsnippet
snippet ife
	if ${1:/* condition */} {
		${2:${VISUAL}}
	} else {
		${0}
	}

endsnippet
snippet el
	else {
		${0:${VISUAL}}
	}

endsnippet
snippet ir
	if err != nil {
		return err
	}
	${0}
endsnippet
snippet f
	false
endsnippet
snippet ft
	fallthrough
endsnippet
snippet fl
	float32
endsnippet
snippet f3
	float32
endsnippet
snippet f6
	float64
endsnippet
snippet for
	for ${1}{
		${0:${VISUAL}}
	}
endsnippet
snippet fori
	for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
		${0:${VISUAL}}
	}
endsnippet
snippet forr
	for ${1:e} := range ${2:collection} {
		${0:${VISUAL}}
	}
endsnippet
snippet fun
	func ${1:funcName}(${2}) ${3:error} {
		${4}
	}
	${0}

endsnippet
snippet fum
	func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
		${6}
	}
	${0}
endsnippet
snippet fumh
	func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {
		${0:${VISUAL}}
	}
endsnippet
snippet lf
	log.Printf("%${1:s}", ${2:var})
endsnippet
snippet lp
	log.Println("${1}")
endsnippet
snippet mk
	make(${1:[]string}, ${0:0})
endsnippet
snippet mp
	map[${1:string}]${0:int}
endsnippet
snippet main
	func main() {
		${1}
	}
	${0}

endsnippet
snippet nw
	new(${0:type})

endsnippet
snippet pa
	package ${1:main}

endsnippet
snippet pn
	panic("${0:msg}")

endsnippet
snippet pr
	fmt.Printf("%${1:s}\n", ${2:var})

endsnippet
snippet pl
	fmt.Println("${1:s}")

endsnippet
snippet rn
	range ${0}

endsnippet
snippet rt
	return ${0}

endsnippet
snippet rs
	result

endsnippet
snippet sl
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	default:
		${0}
	}
endsnippet
snippet sr
	string
endsnippet
snippet st
	struct ${1:name} {
		${2:/* data */}
	}
	${0}

endsnippet
snippet sw
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${0}
	}
endsnippet
snippet sp
	fmt.Sprintf("%${1:s}", ${2:var})
endsnippet
snippet t
	true
endsnippet
snippet g
	go ${1:funcName}(${0})
endsnippet
snippet ga
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${0})
endsnippet
snippet test "function"
	func Test${1:name}(t *testing.T) {
		${0:${VISUAL}}
	}
endsnippet
snippet bench "function"
	func Benchmark${1:name}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${2}
		}
	}
	${0}

endsnippet
snippet cl
	type ${1:name} struct {
		${2:attrName} ${3:attrType}
	}

endsnippet
snippet om
	if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {
		${4:/* code */}
	}

endsnippet
snippet gg
	var ${1:var} = struct{
		${2:name} ${3:type}
	}{
		$2: ${4:value},
	}

endsnippet
snippet ja
	type ${1:parentType}Alias $1

	func (p *$1) MarshalJSON() ([]byte, error) {
		return json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})
	}
endsnippet
# Snippets for Go

priority -50

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet /^import/ "Import declaration" r
import (
	"${1:package}"
)
endsnippet

snippet /^package/ "Package declaration" r
// Package $1 provides ...
package ${1:main}
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet /^cons/ "Constants declaration" r
const (
	${1:constant}${2/(.+)/ /}${2:type} = ${0:value}
)
endsnippet

snippet /^con/ "Constant declaration" r
const ${1:name}${2/(.+)/ /}${2:type} = ${0:value}
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

snippet struct "Struct declaration" b
type ${1:Struct} struct {
	${0:${VISUAL}}
}
endsnippet

snippet interface "Interface declaration" b
type ${1:Interface} interface {
	${0:${VISUAL}}
}
endsnippet

snippet if "If statement" b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet switch "Switch statement" b
switch ${1:expression}${1/(.+)/ /}{
case$0
}
endsnippet

# functions
snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^meth/ "Method" r
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {
	${0:${VISUAL}}
}
endsnippet

snippet func "Function" b
func ${1:name}(${2:params})${3/(.+)/ /}${3:type} {
	${0:${VISUAL}}
}
endsnippet

snippet funch "HTTP handler" b
func ${1:handler}(${2:w} http.ResponseWriter, ${3:r} *http.Request) {
	${0:${VISUAL}}
}
endsnippet

# types and variables
snippet map "Map type" b
map[${1:keytype}]${2:valtype}
endsnippet

snippet : "Variable declaration :=" b
${1:name} := ${0:value}
endsnippet

snippet var "Variable declaration" b
var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}
endsnippet

snippet vars "Variables declaration" b
var (
	${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }
)
endsnippet

snippet json "JSON field"
\`json:"${1:displayName}"\`
endsnippet

# vim:ft=snippets:

# error handling
snippet err "Basic error handling" b
if err != nil {
	log.${1:Fatal}(err)
}
endsnippet
