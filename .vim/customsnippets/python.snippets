
snippet #!
	#!/usr/bin/env python
	# -*- coding: utf-8 -*-
endsnippet
snippet #!2
	#!/usr/bin/env python2
	# -*- coding: utf-8 -*-

endsnippet
snippet #!3
	#!/usr/bin/env python3
	# -*- coding: utf-8 -*-
endsnippet
snippet imp
	import ${0:module}
endsnippet
snippet uni
	def __unicode__(self):
		${0:representation}

endsnippet
snippet from
	from ${1:package} import ${0:module}

endsnippet
snippet docs
	"""
	File: ${1:`vim_snippets#Filename('$1.py', 'foo.py')`}
	Author: `g:snips_author`
	Email: `g:snips_email`
	Github: `g:snips_github`
	Description: ${0}
	"""

endsnippet
snippet wh
	while ${1:condition}:
		${0:${VISUAL}}
endsnippet
snippet dowh
	while True:
		${1}
		if ${0:condition}:
			break

endsnippet
snippet with
	with ${1:expr} as ${2:var}:
		${0:${VISUAL}}
endsnippet
snippet awith
	async with ${1:expr} as ${2:var}:
		${0:${VISUAL}}

endsnippet
snippet cl
	class ${1:ClassName}(${2:object}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:arg}):
			${5:super($1, self).__init__()}
			self.$4 = $4
			${0}
endsnippet
snippet cla
	class ${1:class_name}:
		"""${0:description}"""

endsnippet
snippet clai
	class ${1:class_name}:
		"""${2:description}"""
		def __init__(self, ${3:args}):
			${0}
endsnippet
snippet def
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${0}
endsnippet
snippet deff
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${0}

endsnippet
snippet adef
	async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${0}

endsnippet
snippet adeff
	async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${0}
endsnippet
snippet defi
	def __init__(self, ${1:args}):
		${0}

endsnippet
snippet defm
	def ${1:mname}(self, ${2:arg}):
		${0}
endsnippet
snippet adefm
	async def ${1:mname}(self, ${2:arg}):
		${0}

endsnippet
snippet property
	def ${1:foo}():
		doc = "${2:The $1 property.}"
		def fget(self):
			${3:return self._$1}
		def fset(self, value):
			${4:self._$1 = value}
		def fdel(self):
			${0:del self._$1}
		return locals()
	$1 = property(**$1())
endsnippet
snippet if
	if ${1:condition}:
		${0:${VISUAL}}

endsnippet
snippet el
	else:
		${0:${VISUAL}}
endsnippet
snippet ei
	elif ${1:condition}:
		${0:${VISUAL}}

endsnippet
snippet for
	for ${1:item} in ${2:items}:
		${0}
endsnippet
snippet cutf8
	# -*- coding: utf-8 -*-
endsnippet
snippet clatin1
	# -*- coding: latin-1 -*-
endsnippet
snippet cascii
	# -*- coding: ascii -*-
endsnippet
snippet ld
	${1:var} = lambda ${2:vars} : ${0:action}
endsnippet
snippet ret
	return ${0}
endsnippet
snippet .
	self.
endsnippet
snippet try "Try"/Except
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${0:raise $3}

endsnippet
snippet trye "Try"/Except/Else
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${4:raise $3}
	else:
		${0}
endsnippet
snippet tryf "Try"/Except/Finally
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${4:raise $3}
	finally:
		${0}

endsnippet
snippet tryef "Try"/Except/Else/Finally
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${4:raise $3}
	else:
		${5}
	finally:
		${0}
endsnippet
snippet ifmain
	if __name__ == '__main__':
		${0:main()}

endsnippet
snippet _
	__${1:init}__

endsnippet
snippet pdb
	__import__('pdb').set_trace()

endsnippet
snippet bpdb
	__import__('bpdb').set_trace()

endsnippet
snippet ipdb
	__import__('ipdb').set_trace()

endsnippet
snippet iem
	__import__('IPython').embed()

endsnippet
snippet rpdb
	__import__('rpdb').set_trace()

endsnippet
snippet wdb
	__import__('wdb').set_trace()

endsnippet
snippet ptpython
	__import__('ptpython.repl', fromlist=('repl')).embed(globals(), locals(), vi_mode=${1:False}, history_filename=${2:None})

endsnippet
snippet pudb
	__import__('pudb').set_trace()

endsnippet
snippet nosetrace
	__import__('nose').tools.set_trace()

endsnippet
snippet pprint
	__import__('pprint').pprint(${1})

endsnippet
snippet "
	"""${0:doc}
	"""
endsnippet
snippet a=
	self.assertEqual(${0}, ${1})
endsnippet
snippet test
	def test_${1:description}(${2:`indent('.') ? 'self' : ''`}):
		${0}

endsnippet
snippet testcase
	class ${1:ExampleCase}(unittest.TestCase):

		def test_${2:description}(self):
			${0}
endsnippet
snippet tgwt
	# given: ${1}
	# when: ${2}
	# then: ${3}
endsnippet
snippet fut
	from __future__ import ${0}
endsnippet
snippet getopt
	try:
		# Short option syntax: "hv:"
		# Long option syntax: "help" or "verbose="
		opts, args = getopt.getopt(sys.argv[1:], "${1:short_options}", [${2:long_options}])

	except getopt.GetoptError, err:
		# Print debug info
		print str(err)
		${3:error_action}

	for option, argument in opts:
		if option in ("-h", "--help"):
			${0}
		elif option in ("-v", "--verbose"):
			verbose = argument
endsnippet
snippet addp
	parser = ${VISUAL:argparse.}ArgumentParser()
endsnippet
snippet addsp
	${0:sub_parser} = parser.add_subparsers().add_parser("${1:name}")
endsnippet
snippet addarg
	parser.add_argument("${0:short_arg}", "${1:long_arg}", default=${2:None}, help="${3:Help text}")
endsnippet
snippet addnarg
	parser.add_argument("${0:arg}", nargs="${1:*}", default"${2:None}, help="${3:Help text}")
endsnippet
snippet addaarg
	parser.add_argument("${0:arg}", "${1:long_arg}", action="${2:store_true}", default=${3:False}, help="${4:Help text}")
endsnippet
snippet pargs
	"${VISUAL:return }"parser.parse_args()
	

endsnippet
snippet glog
	import logging
	LOGGER = logging.getLogger(${0:__name__})
endsnippet
snippet le
	LOGGER.error(${0:msg})
endsnippet
snippet lg
	LOGGER.debug(${0:msg})
endsnippet
snippet lw
	LOGGER.warning(${0:msg})
endsnippet
snippet lc
	LOGGER.critical(${0:msg})
endsnippet
snippet li
	LOGGER.info(${0:msg})
endsnippet
snippet epydoc
	"""${1:Description}

	@param ${2:param}: ${3: Description}
	@type  $2: ${4: Type}

	@return: ${5: Description}
	@rtype : ${6: Type}

	@raise e: ${0: Description}
	"""

endsnippet
snippet dol
	def ${1:__init__}(self, *args, **kwargs):
	    super(${0:ClassName}, self).$1(*args, **kwargs)
endsnippet
snippet kwg
	self.${1:var_name} = kwargs.get('$1', ${2:None})
endsnippet
snippet lkwg
	${1:var_name} = kwargs.get('$1', ${2:None})
endsnippet
snippet args
	*args${1:,}${0}
endsnippet
snippet kwargs
	**kwargs${1:,}${0}
endsnippet
snippet akw
	*args, **kwargs${1:,}${0}
endsnippet
snippet lcp "comprehension"
	[${1} for ${2} in ${3:${VISUAL}}]${0}
endsnippet
snippet dcp "comprehension"
	{${1}: ${2} for ${3} in ${4:${VISUAL}}}${0}
endsnippet
snippet scp "comprehension"
	{${1} for ${2} in ${3:${VISUAL}}}${0}
endsnippet
snippet contain "methods for emulating a container type" b
	def __len__(self):
		${1:pass}

	def __getitem__(self, key):
		${2:pass}

	def __setitem__(self, key, value):
		${3:pass}

	def __delitem__(self, key):
		${4:pass}

	def __iter__(self):
		${5:pass}

	def __reversed__(self):
		${6:pass}

	def __contains__(self, item):
		${7:pass}
	
endsnippet
snippet context "context manager methods" b
	def __enter__(self):
		${1:pass}

	def __exit__(self, exc_type, exc_value, traceback):
		${2:pass}
	

endsnippet
snippet attr "methods for customizing attribute access" b
	def __getattr__(self, name):
		${1:pass}

	def __setattr__(self, name, value):
		${2:pass}

	def __delattr__(self, name):
		${3:pass}
	

endsnippet
snippet desc "methods implementing descriptors" b
	def __get__(self, instance, owner):
		${1:pass}

	def __set__(self, instance, value):
		${2:pass}

	def __delete__(self, instance):
		${3:pass}
	

endsnippet
snippet cmp "methods implementing rich comparison"
	def __eq__(self, other):
		${1:pass}

	def __ne__(self, other):
		${2:pass}

	def __lt__(self, other):
		${3:pass}

	def __le__(self, other):
		${4:pass}

	def __gt__(self, other):
		${5:pass}

	def __ge__(self, other):
		${6:pass}

	def __cmp__(self, other):
		${7:pass}
	

endsnippet
snippet repr "methods implementing string representation"
	def __repr__(self):
		${1:pass}

	def __str__(self):
		${2:pass}

	def __unicode__(self):
		${3:pass}
	

endsnippet
snippet numeric "methods for emulating a numeric type" b
	def __add__(self, other):
		${1:pass}

	def __sub__(self, other):
		${2:pass}

	def __mul__(self, other):
		${3:pass}

	def __div__(self, other):
		${4:pass}

	def __truediv__(self, other):
		${5:pass}

	def __floordiv__(self, other):
		${6:pass}

	def __mod__(self, other):
		${7:pass}

	def __divmod__(self, other):
		${8:pass}

	def __pow__(self, other):
		${9:pass}

	def __lshift__(self, other):
		${10:pass}

	def __rshift__(self, other):
		${11:pass}

	def __and__(self, other):
		${12:pass}

	def __xor__(self, other):
		${13:pass}

	def __or__(self, other):
		${14:pass}

	def __neg__(self):
		${15:pass}

	def __pos__(self):
		${16:pass}

	def __abs__(self):
		${17:pass}

	def __invert__(self):
		${18:pass}

	def __complex__(self):
		${19:pass}

	def __int__(self):
		${20:pass}

	def __long__(self):
		${21:pass}

	def __float__(self):
		${22:pass}

	def __oct__(self):
		${22:pass}

	def __hex__(self):
		${23:pass}

	def __index__(self):
		${24:pass}

	def __coerce__(self, other):
		${25:pass}
	
endsnippet
priority -50

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
# -*- coding: utf-8 -*-
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == `!p snip.rv = get_quoting_style(snip)`__main__`!p snip.rv = get_quoting_style(snip)`:
	${1:${VISUAL:main()}}
endsnippet

snippet with "with" b
with ${1:expr}`!p snip.rv = " as " if t[2] else ""`${2:var}:
	${3:${VISUAL:pass}}
$0
endsnippet

snippet for "for loop" b
for ${1:item} in ${2:iterable}:
	${3:${VISUAL:pass}}
endsnippet

##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL  = 0x1
DOXYGEN = 0x2
SPHINX  = 0x3
GOOGLE  = 0x4
NUMPY   = 0x5
JEDI    = 0x6

SINGLE_QUOTES = "'"
DOUBLE_QUOTES = '"'


class Arg(object):
	def __init__(self, arg):
		self.arg = arg
		self.name = arg.split('=')[0].strip()

	def __str__(self):
		return self.name

	def __unicode__(self):
		return self.name

	def is_kwarg(self):
		return '=' in self.arg


def get_args(arglist):
	args = [Arg(arg) for arg in arglist.split(',') if arg]
	args = [arg for arg in args if arg.name != 'self']

	return args


def get_quoting_style(snip):
	style = snip.opt("g:ultisnips_python_quoting_style", "double")
	if style == 'single':
		return SINGLE_QUOTES
	return DOUBLE_QUOTES

def triple_quotes(snip):
	style = snip.opt("g:ultisnips_python_triple_quoting_style")
	if not style:
		return get_quoting_style(snip) * 3
	return (SINGLE_QUOTES if style == 'single' else DOUBLE_QUOTES) * 3

def triple_quotes_handle_trailing(snip, quoting_style):
	"""
	Generate triple quoted strings and handle any trailing quote char,
	which might be there from some autoclose/autopair plugin,
	i.e. when expanding ``"|"``.
	"""
	if not snip.c:
		# Do this only once, otherwise the following error would happen:
		# RuntimeError: The snippets content did not converge: …
		_, col = vim.current.window.cursor
		line = vim.current.line

		# Handle already existing quote chars after the trigger.
		_ret = quoting_style * 3
		while True:
			try:
				nextc = line[col]
			except IndexError:
				break
			if nextc == quoting_style and len(_ret):
				_ret = _ret[1:]
				col = col+1
			else:
				break
		snip.rv = _ret
	else:
		snip.rv = snip.c

def get_style(snip):
	style = snip.opt("g:ultisnips_python_style", "normal")

	if    style == "doxygen": return DOXYGEN
	elif  style == "sphinx": return SPHINX
	elif  style == "google": return GOOGLE
	elif  style == "numpy": return NUMPY
	elif  style == "jedi": return JEDI
	else: return NORMAL


def format_arg(arg, style):
	if style == DOXYGEN:
		return "@param %s TODO" % arg
	elif style == SPHINX:
		return ":param %s: TODO" % arg
	elif style == NORMAL:
		return ":%s: TODO" % arg
	elif style == GOOGLE:
		return "%s (TODO): TODO" % arg
	elif style == JEDI:
		return ":type %s: TODO" % arg
	elif style == NUMPY:
		return "%s : TODO" % arg


def format_return(style):
	if style == DOXYGEN:
		return "@return: TODO"
	elif style in (NORMAL, SPHINX, JEDI):
		return ":returns: TODO"
	elif style == GOOGLE:
		return "Returns: TODO"


def write_docstring_args(args, snip):
	if not args:
		snip.rv += ' {0}'.format(triple_quotes(snip))
		return

	snip.rv += '\n' + snip.mkline('', indent='')

	style = get_style(snip)

	if style == GOOGLE:
		write_google_docstring_args(args, snip)
	elif style == NUMPY:
		write_numpy_docstring_args(args, snip)
	else:
		for arg in args:
			snip += format_arg(arg, style)


def write_google_docstring_args(args, snip):
	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		snip += "Args:"
		snip.shift()
		for arg in args:
			snip += format_arg(arg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')

	if kwargs:
		snip += "Kwargs:"
		snip.shift()
		for kwarg in kwargs:
			snip += format_arg(kwarg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')


def write_numpy_docstring_args(args, snip):
	if args:
		snip += "Parameters"
		snip += "----------"

	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		for arg in args:
			snip += format_arg(arg, NUMPY)
	if kwargs:
		for kwarg in kwargs:
			snip += format_arg(kwarg, NUMPY) + ', optional'
	snip.rv += '\n' + snip.mkline('', indent='')


def write_init_body(args, parents, snip):
	parents = [p.strip() for p in parents.split(",")]
	parents = [p for p in parents if p != 'object']

	for p in parents:
		snip += p + ".__init__(self)"

	if parents:
		snip.rv += '\n' + snip.mkline('', indent='')

	for arg in args:
		snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
	quote = get_quoting_style(snip)
	arg_format = quote + '_%s' + quote
	args = [arg_format % arg for arg in args]
	snip += '__slots__ = (%s,)' % ', '.join(args)


def write_function_docstring(t, snip):
	"""
	Writes a function docstring with the current style.

	:param t: The values of the placeholders
	:param snip: UltiSnips.TextObjects.SnippetUtil object instance
	"""
	snip.rv = ""
	snip >> 1

	args = get_args(t[2])
	if args:
		write_docstring_args(args, snip)

	style = get_style(snip)

	if style == NUMPY:
		snip += 'Returns'
		snip += '-------'
		snip += 'TODO'
	else:
		snip += format_return(style)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)

def get_dir_and_file_name(snip):
	return os.getcwd().split(os.sep)[-1] + '.' + snip.basename

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):

	`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`

	def __init__(self$4):
		`!p snip.rv = triple_quotes(snip)`${5:TODO: to be defined1.}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += '{0}'.format(triple_quotes(snip))

write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):

	`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`
`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		`!p snip.rv = triple_quotes(snip)`${5:TODO: to be defined.}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)

write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
	${1:pass}

def __str__(self):
	${2:pass}

def __unicode__(self):
	${3:pass}
endsnippet


# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
def __add__(self, other):
	${1:pass}

def __sub__(self, other):
	${2:pass}

def __mul__(self, other):
	${3:pass}

def __div__(self, other):
	${4:pass}

def __truediv__(self, other):
	${5:pass}

def __floordiv__(self, other):
	${6:pass}


def __mod__(self, other):
	${7:pass}

def __divmod__(self, other):
	${8:pass}

def __pow__(self, other):
	${9:pass}


def __lshift__(self, other):
	${10:pass}

def __rshift__(self, other):
	${11:pass}

def __and__(self, other):
	${12:pass}

def __xor__(self, other):
	${13:pass}

def __or__(self, other):
	${14:pass}


def __neg__(self):
	${15:pass}

def __pos__(self):
	${16:pass}

def __abs__(self):
	${17:pass}

def __invert__(self):
	${18:pass}


def __complex__(self):
	${19:pass}

def __int__(self):
	${20:pass}

def __long__(self):
	${21:pass}

def __float__(self):
	${22:pass}


def __oct__(self):
	${22:pass}

def __hex__(self):
	${23:pass}


def __index__(self):
	${24:pass}

def __coerce__(self, other):
	${25:pass}
endsnippet

snippet deff
def ${1:fname}(`!p snip.rv = vim.eval('indent(".") ? "self" : ""')`$2):
	$0
endsnippet

snippet def "function with docstrings" b
def ${1:function}(`!p
if snip.indent:
	snip.rv = 'self' + (", " if len(t[2]) else "")`${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


snippet defc "class method with docstrings" b
@classmethod
def ${1:function}(`!p
if snip.indent:
	snip.rv = 'cls' + (", " if len(t[2]) else "")`${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


snippet defs "static method with docstrings" b
@staticmethod
def ${1:function}(${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


# doesn't expand when there is a word in front
snippet /(^|(?<=\W))\./ "self." r
self.
endsnippet

snippet from "from module import name" b
from ${1:module} import ${2:Stuff}
endsnippet


##############
# PROPERTIES #
##############
snippet roprop "Read Only Property" b
@property
def ${1:name}(self):
	${2:return self._$1}$0
endsnippet

snippet rwprop "Read write property" b
def ${1:name}():
	`!p snip.rv = triple_quotes(snip) if t[2] else ''
`${2:TODO: Docstring for $1.}`!p
if t[2]:
	snip >> 1

	style = get_style(snip)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += format_return(style)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)
else:
	snip.rv = ""`
	def fget(self):
		return self._$1$0

	def fset(self, value):
		self._$1 = value
	return locals()

$1 = property(**$1(), doc=$1.__doc__)
endsnippet


####################
# If / Else / Elif #
####################
snippet if "If" b
if ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet

snippet ife "If / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
else:
	${3:pass}
endsnippet

snippet ifee "If / Elif / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
elif ${3:condition}:
	${4:pass}
else:
	${5:pass}
endsnippet


##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
endsnippet

snippet trye "Try / Except / Else" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet tryf "Try / Except / Finally" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet tryef "Try / Except / Else / Finally" b
try:
	${1:${VISUAL:pass}}
except${2: ${3:Exception} as ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet


######################
# Assertions & Tests #
######################

snippet ae "Assert equal" b
self.assertEqual(${1:${VISUAL:first}},${2:second})
endsnippet

snippet at "Assert True" b
self.assertTrue(${1:${VISUAL:expression}})
endsnippet

snippet af "Assert False" b
self.assertFalse(${1:${VISUAL:expression}})
endsnippet

snippet aae "Assert almost equal" b
self.assertAlmostEqual(${1:${VISUAL:first}},${2:second})
endsnippet

snippet ar "Assert raises" b
self.assertRaises(${1:exception}, ${2:${VISUAL:func}}${3/.+/, /}${3:arguments})
endsnippet

snippet an "Assert is None" b
self.assertIsNone(${1:${VISUAL:expression}})
endsnippet

snippet ann "Assert is not None" b
self.assertIsNotNone(${1:${VISUAL:expression}})
endsnippet

snippet testcase "pyunit testcase" b
class Test${1:Class}(${2:unittest.TestCase}):

	`!p snip.rv = triple_quotes(snip)`${3:Test case docstring.}`!p snip.rv = triple_quotes(snip)`

	def setUp(self):
		${4:pass}

	def tearDown(self):
		${5:pass}

	def test_${6:name}(self):
		${7:${VISUAL:pass}}
endsnippet

snippet " "triple quoted string (double quotes)" b
"""
${1:${VISUAL:doc}}
`!p triple_quotes_handle_trailing(snip, '"')`
endsnippet

snippet ' "triple quoted string (single quotes)" b
'''
${1:${VISUAL:doc}}
`!p triple_quotes_handle_trailing(snip, "'")`
endsnippet

snippet doc "doc block (triple quotes)"
`!p snip.rv = triple_quotes(snip)`
${1:${VISUAL:doc}}
`!p snip.rv = triple_quotes(snip)`
endsnippet

snippet pmdoc "pocoo style module doc string" b
# -*- coding: utf-8 -*-
"""
	`!p snip.rv = get_dir_and_file_name(snip)`
	`!p snip.rv = '~' * len(get_dir_and_file_name(snip))`

	${1:DESCRIPTION}

	:copyright: (c) `date +%Y` by ${2:YOUR_NAME}.
	:license: ${3:LICENSE_NAME}, see LICENSE for more details.
"""
$0
endsnippet

# vim:ft=snippets:
