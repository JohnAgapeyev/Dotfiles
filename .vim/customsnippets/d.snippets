
snippet imp
	import 

endsnippet
snippet pimp
	public import

endsnippet
snippet io
	std.stdio

endsnippet
snippet traits
	std.traits

endsnippet
snippet conv
	std.conv

endsnippet
snippet arr
	std.array

endsnippet
snippet algo
	std.algorithm

endsnippet
snippet theusual
	import std.stdio, std.string, std.array;
	import std.traits, std.conv, std.algorithm;
	import std.math, std.regex;

endsnippet
snippet for
	for(int ${1:i} = 0; $1 < ${2:count}; $1++) {
		${0}
	}

endsnippet
snippet fe
	foreach(${1:elem}; ${2:range}) {
		${0}
	}

endsnippet
snippet fei
	foreach(${1:i}, ${2:elem}; ${3:range}) {
		${0}	
	} 

endsnippet
snippet fer
	foreach_reverse(${1:elem}; ${2:range}) {
		${0}	
	} 

endsnippet
snippet feri
	foreach_reverse(${1:i}, ${2:elem}; ${3:range}) {
		${0}  
	}

endsnippet
snippet sce
	scope(exit) ${1:f.close();}

endsnippet
snippet scs
	scope(success) ${1}

endsnippet
snippet scf
	scope(failure) ${1}

endsnippet
snippet el
	else {
		${1}	
	}

endsnippet
snippet eif
	else if(${1}) {
		${0}
	}

endsnippet
snippet if
	if(${1}) {
		${0}
	}

endsnippet
snippet ife
	if(${1}) {
		${2}	
	} else {
		${3}	
	}

endsnippet
snippet ifee
	if(${1}) {
		${2}	
	} else if(${3}) {
		${4}
	} else {
		${5}
	}

endsnippet
snippet sw
	switch(${1}) {
		${0}
	}

endsnippet
snippet cs
	case ${1:0}:
		${2}
		break;

endsnippet
snippet def
	default:
		${0}
endsnippet
snippet fsw
	final switch(${1}) {
		${0}
	}
endsnippet
snippet try
	try {
		${1:${VISUAL}}
	} catch(${2:Exception} ${3:e}) {
		${4}
	}
endsnippet
snippet tcf
	try {
		${0:${VISUAL}}
	} catch(${1:Exception} ${2:e}) {
		${3}
	} finally {
		${4}
	}
endsnippet
snippet wh
	while(${1:cond}) {
		${0:${VISUAL}}
	}
endsnippet
snippet dowh
	do {
		${1}
	} while(${2});
endsnippet
snippet sif
	static if(${1:cond}) {
		${2}
	}
endsnippet
snippet sife
	static if(${1}) {
		${2}
	} else {
		${3}
	}
endsnippet
snippet sifee
	static if(${1}) {
		${2}
	} else static if(${3}) {
		${4}
	} else {
		${5}
	}
endsnippet
snippet seif
	else static if(${1}) {
		${2}
	} 
endsnippet
snippet ?
	(${1: a > b}) ? ${2:a} : ${3:b}; 
endsnippet
snippet with
	with(${1:exp}) {
		${2}
	} ${0}	
endsnippet
snippet fun
	${1:auto} ${2:func}(${3:params}) {
		${0}
	}
endsnippet
snippet contr
	in {
		${1}
	} out {
		${2}
	} body {
		${0}
	}
endsnippet
snippet l
	(${1:x}) => ${2:x}${0:;}
endsnippet
snippet funl
	function (${1:int x}) => ${2}${3:;}
endsnippet
snippet del
	delegate (${1:int x}) => ${2}${3:;} 
endsnippet
snippet temp 
	template ${1:`vim_snippets#Filename("$2", "untitled")`}(${2:T}) {
		${0}
	}
endsnippet
snippet tempif
	template ${1:`vim_snippets#Filename("$2", "untitled")`}(${2:T}) if(${3:isSomeString!}$2) {
		${0}	
	}
endsnippet
snippet opApply
	int opApply(Dg)(Dg dg) if(ParameterTypeTuble!Dg.length == 2) {
		${0}
	}
endsnippet
snippet psn
	pure @safe nothrow
endsnippet
snippet safe
	@safe
endsnippet
snippet trusted
	@trusted
endsnippet
snippet	system
	@system
endsnippet
snippet cl
	class${1:(T)} ${2:`vim_snippets#Filename("$3", "untitled")`} {
		${0}	
	}
endsnippet
snippet str
	struct${1:(T)} ${2:`vim_snippets#Filename("$3", "untitled")`} {
		${0}	
	}
endsnippet
snippet uni
	union${1:(T)} ${2:`vim_snippets#Filename("$3", "untitled")`} {
		${0}	
	}
endsnippet
snippet inter
	interface I${1:`vim_snippets#Filename("$2", "untitled")`} {
		${0}
	}
endsnippet
snippet enum
	enum ${1} {
		${0}
	}
endsnippet
snippet pu
	public
endsnippet
snippet pr
	private
endsnippet
snippet po
	protected
endsnippet
snippet ctor
	this(${1}) {
		${0}
	} 
endsnippet
snippet dtor
	~this(${1}) {
		${0}
	}
endsnippet
snippet al
	alias ${1:b} = ${2:a};
	${0}

endsnippet
snippet alth
	alias ${1:value} this;
	${0}
endsnippet
snippet main
	void main() {
		${0}
	}
endsnippet
snippet maina
	void main(string[] args) {
		${0}
	}
endsnippet
snippet mod
	module ${1:main};${0}
endsnippet
snippet var
	${1:auto} ${2:var} = ${0:1};
endsnippet
snippet new
	${1:auto} ${2:var} = new ${3:Object}(${4});
	${0}

endsnippet
snippet file
	auto ${1:f} = File(${2:"useful_info.xml"}, ${3:"rw"});
	${0}
endsnippet
snippet map
	map!(${1:f})(${2:xs});
	${0}

endsnippet
snippet filter
	filter!(${1:p})(${2:xs});
	${0}
endsnippet
snippet reduce
	reduce!(${1:f})(${2:xs});
	${0}

endsnippet
snippet find
	find!(${1:p})($2:xs);
	${0}
endsnippet
snippet aa
	${1:int}[${2:string}] ${3:dict} = ${0};
endsnippet
snippet #!
	#!/usr/bin/env rdmd
endsnippet
snippet bang
	#!/usr/bin/env rdmd
endsnippet
snippet rdmd
	#!/usr/bin/env rdmd
endsnippet
snippet isstr
	isSomeString!${1:S}
endsnippet
snippet isnum
	isNumeric!${1:N}
endsnippet
snippet tos
	to!string(${1:x});
	${0}

endsnippet
snippet toi
	to!int(${1:str});
	${0}
endsnippet
snippet tod
	to!double(${1:str});
	${0}

endsnippet
snippet un
	unittest {
		${0}
	}

endsnippet
snippet ver
	version(${1:Posix}) {
		${0}
	}

endsnippet
snippet de
	debug {
		${0}
	}

endsnippet
snippet sst
	shared static this(${1}) {
		${0}
	}

endsnippet
snippet td
	// Typedef is deprecated. Use alias instead.
	typedef
endsnippet
snippet ino
	inout
endsnippet
snippet imm
	immutable
endsnippet
snippet fin
	final
endsnippet
snippet con
	const
endsnippet
snippet psi
	private static immutable ${1:int} ${2:Constant} = ${3:1};
	${0}

endsnippet
snippet prag
	pragma(${1})

endsnippet
snippet pms
	pragma(msg, ${1:Warning});

endsnippet
snippet asm
	asm {
		${1}
	}

endsnippet
snippet mixin
	mixin(${1:`writeln("Hello, World!");`});

endsnippet
snippet over
	override

endsnippet
snippet ret
	return ${1};

endsnippet
snippet FILE
	__FILE__

endsnippet
snippet MOD
	__MODULE__

endsnippet
snippet LINE
	__LINE__

endsnippet
snippet FUN
	__FUNCTION__

endsnippet
snippet PF
	__PRETTY_FUNCTION__

endsnippet
snippet cast
	cast(${1:T})(${2:val});

endsnippet
snippet /*
	/*
	 * ${1}
	*/

endsnippet
snippet idk
	// I don't know how this works. Don't touch it.

endsnippet
snippet idfk
	// Don't FUCKING touch this.
endsnippet
# Simple shortcuts

priority -50

snippet imp "import (imp)" b
import ${1:std.stdio};
endsnippet

snippet pimp "public import (pimp)" b
public import ${1:/*module*/};
endsnippet

snippet over "override (over)" b
override ${1:/*function*/}
endsnippet

snippet al "alias (al)"
alias ${1:/*orig*/} ${2:/*alias*/};
endsnippet

snippet mixin "mixin (mixin)" b
mixin ${1:/*mixed_in*/} ${2:/*name*/};
endsnippet

snippet new "new (new)"
new $1($2);
endsnippet

snippet scpn "@safe const pure nothrow (scpn)"
@safe const pure nothrow
endsnippet

snippet spn "@safe pure nothrow (spn)"
@safe pure nothrow
endsnippet

snippet cont "continue (cont)"
continue;
endsnippet

snippet dis "@disable (dis)" b
@disable ${1:/*method*/};
endsnippet

snippet pub "public (pub)" b
public:
	${1:/*members*/}
endsnippet

snippet priv "private (priv)" b
private:
	${1:/*members*/}
endsnippet

snippet prot "protected (prot)" b
protected:
	${1:/*members*/}
endsnippet

snippet pack "package (pack)" b
package:
	${1:/*members*/}
endsnippet

snippet ret "return (ret)"
return ${1:/*value to return*/};
endsnippet

snippet auto "auto (auto)" b
auto ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet con "const (con)" b
const ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet siz "size_t (siz)" b
size_t ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet sup "super (sup)" b
super(${1:/*args*/});
endsnippet

# Phobos

snippet tup "tuple (tup)"
tuple(${1:/*args*/})
endsnippet

snippet wr "writeln (wr)"
writeln(${1:/*args*/});
endsnippet

snippet to "to (to)"
to!(${1:/*type*/})(${2:/*arg*/})
endsnippet

snippet enf "enforce (enf)" b
enforce(${1:/*condition*/},
	new $2Exception(${3:/*args*/}));
endsnippet

# Branches

snippet if "if .. (if)"
if(${1:/*condition*/})
{
	${VISUAL}$0
}
endsnippet

snippet ife "if .. else (ife)" b
if(${1:/*condition*/})
{
	$2
}
else
{
	${3:/*else*/}
}
endsnippet

snippet el "else (el)" b
else
{
	${VISUAL}$1
}
endsnippet

snippet elif "else if (elif)" b
else if(${1:/*condition*/})
{
	${VISUAL}$0
}
endsnippet

snippet sw "switch (sw)"
switch(${1:/*var*/})
{
	case ${2:/*value*/}:
		$3
		break;
	case ${4:/*value*/}:
		$5
		break;
	${7:/*more cases*/}
	default:
		${6:assert(false);}
}
endsnippet

snippet fsw "final switch (fsw)"
final switch(${1:/*var*/})
{
	case ${2:/*value*/}:
		$3
		break;
	case ${4:/*value*/}:
		$5
		break;
	${7:/*more cases*/}
}
endsnippet

snippet case "case (case)" b
case ${1:/*value*/}:
	$2
	break;
endsnippet

snippet ?: "ternary operator (?:)"
${1:/*condition*/} ? ${2:/*then*/} : ${3:/*else*/}$4
endsnippet

# Loops

snippet do "do while (do)" b
do
{
	${VISUAL}$2
} while(${1:/*condition*/});
endsnippet

snippet wh "while (wh)" b
while(${1:/*condition*/})
{
	${VISUAL}$2
}
endsnippet

snippet for "for (for)" b
for (${4:size_t} ${2:i} = 0; $2 < ${1:count}; ${3:++$2})
{
	${VISUAL}$0
}
endsnippet

snippet forever "forever (forever)" b
for(;;)
{
	${VISUAL}$0
}
endsnippet

snippet fore "foreach (fore)"
foreach(${1:/*elem*/}; ${2:/*range*/})
{
	${VISUAL}$3
}
endsnippet

snippet forif "foreach if (forif)" b
foreach(${1:/*elem*/}; ${2:/*range*/}) if(${3:/*condition*/})
{
	${VISUAL}$4
}
endsnippet

# Contracts
snippet in "in contract (in)" b
in
{
	assert(${1:/*condition*/}, "${2:error message}");
	$3
}
body
endsnippet

snippet out "out contract (out)" b
out${1:(result)}
{
	assert(${2:/*condition*/}, "${3:error message}");
	$4
}
body
endsnippet

snippet inv "invariant (inv)" b
invariant()
{
	assert(${1:/*condition*/}, "${2:error message}");
	$3
}
endsnippet

# Functions (generic)

snippet fun "function definition (fun)"
${1:void} ${2:/*function name*/}(${3:/*args*/}) ${4:@safe pure nothrow}
{
	${VISUAL}$5
}
endsnippet

snippet void "void function definition (void)"
void ${1:/*function name*/}(${2:/*args*/}) ${3:@safe pure nothrow}
{
	${VISUAL}$4
}
endsnippet

snippet this "ctor (this)" w
this(${1:/*args*/})
{
	${VISUAL}$2
}
endsnippet

snippet get "getter property (get)"
@property ${1:/*type*/} ${2:/*member_name*/}() const pure nothrow {return ${3:$2_};}
endsnippet

snippet set "setter property (set)"
@property void ${1:/*member_name*/}(${2:/*type*/} rhs) pure nothrow {${3:$1_} = rhs;}
endsnippet

# Functions (concrete)

snippet main "Main" b
void main(string[] args)
{
	${VISUAL}${0: /*code*/}
}
endsnippet

# Mixins

snippet signal "signal (signal)" b
mixin Signal!(${1:/*args*/}) ${2:/*name*/};
endsnippet

# Scope

snippet scope "scope (scope)" b
scope(${1:exit})
{
	${VISUAL}$2
}
endsnippet

# With

snippet with "with (with)"
with($1)
{
	${VISUAL}$2
}
endsnippet

# Exception handling

snippet try "try/catch (try)" b
try
{
	${VISUAL}${1:/*code to try*/}
}
catch($2Exception e)
{
	${3:/*handle exception*/}
}
endsnippet

snippet tryf "try/catch/finally (tryf)" b
try
{
	${VISUAL}${1:/*code to try*/}
}
catch($2Exception e)
{
	${3:/*handle exception*/}
}
finally
{
	${4:/*cleanup*/}
}
endsnippet

snippet catch "catch (catch)" b
catch($1Exception e)
{
	${2:/*handle exception*/}
}
endsnippet

snippet thr "throw (thr)"
throw new $1Exception("$2");
endsnippet


# Type declarations

snippet struct "struct (struct)"
struct ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet union "union (union)"
union ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet class "class (class)"
class ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet inter "interface (inter)"
interface ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet enum "enum (enum)"
enum ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet


# Exception declarations

snippet exc "exception declaration (exc)" b
/// ${3:/*documentation*/}
class $1Exception : $2Exception
{
	public this(string msg, string file = __FILE__, int line = __LINE__)
	{
		super(msg, file, line);
	}
}
endsnippet


# Conditional compilation

snippet version "version (version)" b
version(${1:/*version name*/})
{
	${VISUAL}$2
}
endsnippet

snippet debug "debug" b
debug
{
	${VISUAL}$1
}
endsnippet


# Templates

snippet temp "template (temp)" b
template ${2:/*name*/}(${1:/*args*/})
{
	$3
}
endsnippet


# Asserts

snippet ass "assert (ass)" b
assert(${1:false}, "${2:TODO}");

endsnippet


# Unittests

snippet unittest "unittest (unittest)" b
unittest
{
	$1
}
endsnippet


# Common member functions

snippet opDis "opDispatch (opDis)" b
${1:/*return type*/} opDispatch(string s)()
{
	$2;
}
endsnippet

snippet op= "opAssign (op=)" b
void opAssign($1 rhs) ${2:@safe pure nothrow}
{
	$2
}
endsnippet

snippet opCmp "opCmp (opCmp)" b
int opCmp($1 rhs) @safe const pure nothrow
{
	$2
}
endsnippet

snippet opApply "opApply (opApply)" b
int opApply(int delegate(ref ${1:/*iterated type/s*/}) dg)
{
	int result = 0;
	${2:/*loop*/}
	{
		result = dg(${3:/*arg/s*/});
		if(result){break;}
	}
	return result;
}
endsnippet

snippet toString "toString (toString)" b
string toString() @safe const pure nothrow
{
	$1
}
endsnippet


# Comments


snippet todo "TODO (todo)"
// TODO: $1
endsnippet


# DDoc

snippet doc "generic ddoc block (doc)" b
/// ${1:description}
///
/// ${2:details}
endsnippet

snippet fdoc "function ddoc block (fdoc)" b
/// ${1:description}
///
/// ${2:Params:  ${3:param} = ${4:param description}
///			 $5}
///
/// ${6:Returns: ${7:return value}}
///
/// ${8:Throws:  $9Exception $10}
endsnippet

snippet Par "Params (Par)"
Params:  ${1:param} = ${2:param description}
///			$3
endsnippet

snippet Ret "Returns (Ret)"
Returns:  ${1:return value/s}
endsnippet

snippet Thr "Throws (Thr)"
Throws:  $1Exception $2
endsnippet

snippet Example "Examples (Example)"
Examples:
/// --------------------
/// ${1:example code}
/// --------------------
endsnippet


# License blocks

snippet gpl "GPL (gpl)" b
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// Copyright (C) ${1:Author}, `!v strftime("%Y")`

$2
endsnippet

snippet boost "Boost (boost)" b
//          Copyright ${1:Author} `!v strftime("%Y")`.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

$2
endsnippet


# New module

snippet module "New module (module)" b
//          Copyright ${1:Author} `!v strftime("%Y")`.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

module $2.`!v vim_snippets#Filename('$1', 'name')`;


$3
endsnippet
