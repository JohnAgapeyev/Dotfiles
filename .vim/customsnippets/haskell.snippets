
snippet lang
	{-# LANGUAGE ${0:OverloadedStrings} #-}

endsnippet
snippet haddock
	{-# OPTIONS_HADDOCK ${0:hide} #-}

endsnippet
snippet ghc
	{-# OPTIONS_GHC ${0:-fno-warn-unused-imports} #-}

endsnippet
snippet inline
	{-# INLINE ${0:name} #-}

endsnippet
snippet info
	-- |
	-- Module      :  ${1:`substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`}
	-- Copyright   :  ${2:Author} ${3:2011-2012}
	-- License     :  ${4:BSD3}
	--
	-- Maintainer  :  ${5:email@something.com}
	-- Stability   :  ${6:experimental}
	-- Portability :  ${7:unknown}
	--
	-- ${0:Description}
	--

endsnippet
snippet imp
	import ${0:Data.Text}

endsnippet
snippet import
	import           ${0:Data.Text}

endsnippet
snippet import2
	import           ${1:Data.Text} (${0:head})

endsnippet
snippet impq
	import qualified ${1:Data.Text} as ${0:T}

endsnippet
snippet importq
	import qualified ${1:Data.Text} as ${0:T}

endsnippet
snippet inst
	instance ${1:Monoid} ${2:Type} where
		${0}
endsnippet
snippet ty
	type ${1:Type} = ${0:Type}
endsnippet
snippet type
	type ${1:Type} = ${0:Type}
endsnippet
snippet da
	data ${1:Type} = ${2:$1} ${0:Int}
endsnippet
snippet data
	data ${1:Type} = ${2:$1} ${0:Int}
endsnippet
snippet newtype
	newtype ${1:Type} = ${2:$1} ${0:Int}
endsnippet
snippet class
	class ${1:Class} a where
		${0}

endsnippet
snippet module
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (
	) where
	`expand('%') =~ 'Main' ? "\nmain :: IO ()\nmain = undefined" : ""`

endsnippet
snippet mod
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`
		( ${1}
		) where

	`expand('%') =~ 'Main' ? "\nmain :: IO ()\nmain = undefined" : ""`

endsnippet
snippet main
	main :: IO ()
	main = ${0:undefined}
endsnippet
snippet const
	${1:name} :: ${2:a}
	$1 = ${0:undefined}

endsnippet
snippet fn
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4} = ${0:undefined}
endsnippet
snippet fn0
	${1:fn} :: ${2:a}
	$1 = ${0:undefined}

endsnippet
snippet fn1
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4} = ${0:undefined}
endsnippet
snippet fn2
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5} = ${0:undefined}

endsnippet
snippet fn3
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6} = ${0:undefined}
endsnippet
snippet => "Type constraint"
	(${1:Class} ${2:a}) => $2
endsnippet
snippet ap
	${1:map} ${2:fn} ${0:list}
endsnippet
snippet \
	\\${1:x} -> ${0:expression}
endsnippet
snippet (\
	(\\${1:x} -> ${0:expression})
endsnippet
snippet <-
	${1:a} <- ${0:m a}
endsnippet
snippet ->
	${1:m a} -> ${0:a}
endsnippet
snippet tup
	(${1:a}, ${0:b})
endsnippet
snippet tup2
	(${1:a}, ${2:b}, ${0:c})
endsnippet
snippet tup3
	(${1:a}, ${2:b}, ${3:c}, ${0:d})
endsnippet
snippet rec
	${1:Record} { ${2:recFieldA} = ${3:undefined}
				, ${4:recFieldB} = ${0:undefined}
				}
endsnippet
snippet case
	case ${1:something} of
		${2} -> ${0}

endsnippet
snippet let
	let ${1} = ${2}
	in ${3}
endsnippet
snippet where
	where
		${1:fn} = ${0:undefined}

endsnippet
snippet spec
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (main, spec) where

	import Test.Hspec
	import Test.QuickCheck

	main :: IO ()
	main = hspec spec

	spec :: Spec
	spec =
		describe "${1}" $ do
			it "${2}" $
				$0

endsnippet
snippet specf
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (main, spec) where

	import Test.Hspec
	import Test.Hspec.Runner (configFastFail, defaultConfig, hspecWith)

	main :: IO ()
	main = hspecWith defaultConfig {configFastFail = True} spec

	spec :: Spec
	spec =
		describe "${1}" $ do
			it "${2}" $
				$0

endsnippet
snippet desc
	describe "${1}" $ do
		$0
endsnippet
snippet it
	it "${1}" $
		$0

endsnippet
snippet itp
	it "${1}" $ property $
		$0
endsnippet
snippet sb
	\`shouldBe\` $0
endsnippet
snippet doc
	{-| ${0}
	-}
endsnippet
priority -50

snippet impq "Qualified import"
import qualified ${1:Data.Text} as ${0:`!p snip.rv = t[1].split(".")[-1]`}
endsnippet
